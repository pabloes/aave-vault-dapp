{
  "language": "Solidity",
  "sources": {
    "contracts/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { TimelockAaveVault } from \"./TimelockAaveVault.sol\";\nimport { IPool, IPoolAddressesProvider, IProtocolDataProvider } from \"./interfaces/IAaveV3.sol\";\n\n/// @title VaultFactory\n/// @notice Creates timelock Aave vaults and keeps an on-chain index per owner.\ncontract VaultFactory {\n    event VaultCreated(address indexed owner, address vault, address asset, address pool, address aToken, uint256 releaseTime);\n\n    mapping(address => address[]) private _ownerToVaults;\n\n    function createVault(\n        address asset,\n        address pool,\n        uint256 releaseTime\n    ) external returns (address vault) {\n        // Derive aToken via Data Provider for robustness across versions\n        address provider = IPool(pool).ADDRESSES_PROVIDER();\n        address dataProvider = IPoolAddressesProvider(provider).getPoolDataProvider();\n        (address aTokenAddress,,) = IProtocolDataProvider(dataProvider).getReserveTokensAddresses(asset);\n        require(aTokenAddress != address(0), \"Asset not supported by pool\");\n        \n        TimelockAaveVault v = new TimelockAaveVault(msg.sender, asset, pool, aTokenAddress, releaseTime);\n        vault = address(v);\n        _ownerToVaults[msg.sender].push(vault);\n        emit VaultCreated(msg.sender, vault, asset, pool, aTokenAddress, releaseTime);\n    }\n\n    function getVaultsByOwner(address owner) external view returns (address[] memory) {\n        return _ownerToVaults[owner];\n    }\n}\n"
    },
    "contracts/TimelockAaveVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IPool, IERC20 } from \"./interfaces/IAaveV3.sol\";\n\ninterface IERC20Permit {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n/// @title TimelockAaveVault\n/// @notice A self-custodied, non-upgradeable timelock vault that deposits into Aave V3.\n/// Owner is immutable and there are no admin backdoors.\ncontract TimelockAaveVault {\n    event Deposited(address indexed owner, uint256 amount);\n    event Withdrawn(address indexed owner, uint256 amount, address to);\n    event LockExtended(uint256 oldReleaseTime, uint256 newReleaseTime);\n    event ATokensSwept(address indexed owner, uint256 amount, address to);\n\n    address public immutable owner;\n    IERC20 public immutable asset;\n    IPool public immutable pool;\n    IERC20 public immutable aToken;\n\n    uint256 public releaseTime; // unix timestamp after which withdrawals are allowed\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    constructor(\n        address _owner,\n        address _asset,\n        address _pool,\n        address _aToken,\n        uint256 _releaseTime\n    ) {\n        require(_owner != address(0), \"owner=0\");\n        require(_asset != address(0), \"asset=0\");\n        require(_pool != address(0), \"pool=0\");\n        require(_aToken != address(0), \"aToken=0\");\n        require(_releaseTime > block.timestamp, \"release in past\");\n        owner = _owner;\n        asset = IERC20(_asset);\n        pool = IPool(_pool);\n        aToken = IERC20(_aToken);\n        releaseTime = _releaseTime;\n    }\n\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"amount=0\");\n        require(asset.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n        require(asset.approve(address(pool), amount), \"approve failed\");\n        pool.supply(address(asset), amount, address(this), 0);\n        emit Deposited(msg.sender, amount);\n    }\n\n    function depositWithPermit(\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(amount > 0, \"amount=0\");\n        IERC20Permit(address(asset)).permit(msg.sender, address(this), amount, deadline, v, r, s);\n        require(asset.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n        require(asset.approve(address(pool), amount), \"approve failed\");\n        pool.supply(address(asset), amount, address(this), 0);\n        emit Deposited(msg.sender, amount);\n    }\n\n    function maxWithdrawable() public view returns (uint256) {\n        return aToken.balanceOf(address(this));\n    }\n\n    function withdraw(uint256 amount, address to) external onlyOwner {\n        require(block.timestamp >= releaseTime, \"locked\");\n        require(amount > 0, \"amount=0\");\n        require(to != address(0), \"to=0\");\n        uint256 withdrawn = pool.withdraw(address(asset), amount, to);\n        require(withdrawn == amount, \"partial withdraw\");\n        emit Withdrawn(msg.sender, amount, to);\n    }\n\n    function withdrawAll(address to) external onlyOwner {\n        require(block.timestamp >= releaseTime, \"locked\");\n        require(to != address(0), \"to=0\");\n        uint256 amount = maxWithdrawable();\n        pool.withdraw(address(asset), type(uint256).max, to);\n        emit Withdrawn(msg.sender, amount, to);\n    }\n\n    function sweepATokensAfterRelease(address to) external onlyOwner {\n        require(block.timestamp >= releaseTime, \"locked\");\n        require(to != address(0), \"to=0\");\n        uint256 amount = aToken.balanceOf(address(this));\n        require(amount > 0, \"no aTokens\");\n        require(aToken.transfer(to, amount), \"transfer failed\");\n        emit ATokensSwept(msg.sender, amount, to);\n    }\n\n    function extendLock(uint256 newReleaseTime) external onlyOwner {\n        require(newReleaseTime > releaseTime, \"must increase\");\n        uint256 old = releaseTime;\n        releaseTime = newReleaseTime;\n        emit LockExtended(old, newReleaseTime);\n    }\n}\n"
    },
    "contracts/interfaces/IAaveV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IPool {\n    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n    function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n    function ADDRESSES_PROVIDER() external view returns (address);\n    function getReserveData(address asset) external view returns (\n        uint256 configuration,\n        uint128 liquidityIndex,\n        uint128 variableBorrowIndex,\n        uint128 currentLiquidityRate,\n        uint128 currentVariableBorrowRate,\n        uint128 currentStableBorrowRate,\n        uint40 lastUpdateTimestamp,\n        address aTokenAddress,\n        address stableDebtTokenAddress,\n        address variableDebtTokenAddress,\n        address interestRateStrategyAddress,\n        uint8 id\n    );\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function decimals() external view returns (uint8);\n}\n\ninterface IPoolAddressesProvider {\n    function getPool() external view returns (address);\n    function getPoolDataProvider() external view returns (address);\n}\n\ninterface IProtocolDataProvider {\n    function getReserveTokensAddresses(address asset) external view returns (\n        address aTokenAddress,\n        address stableDebtTokenAddress,\n        address variableDebtTokenAddress\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": { "enabled": true, "runs": 200 },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": ["abi", "evm.bytecode", "evm.deployedBytecode"],
        "": ["ast"]
      }
    }
  }
}

